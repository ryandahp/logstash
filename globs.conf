input {
	pipeline { 
            address => globs 
    }
}

filter{
    
    mutate { 
				gsub => [ "message", "\n\n", "" ]   
	}
    
    grok {
			 patterns_dir => ["patterns"]
			 match => [ "message", "%{GLOBS_M1}" ]
	}
    
    date {
				match => ["date1" , "MMM dd, yyyy h:mm:ss a"]
				target => "@timestamp"
	}
            
	mutate {
				add_field => {"from_pipelines" => "globs"}

    }
    
    if [xmessage] =~ "HTTP request" {
        mutate {
                gsub => [ "xmessage", "\n", ";" ]  
				add_field => {"trx_type" => "http_request"}

        }
        if [xmessage] =~ "\[HTTP request\]" {
            if [xmessage] =~ "soapenv" {
                grok {
                     patterns_dir => ["patterns"]
                     match => [ "xmessage", "<---\[HTTP request\]---;%{GREEDYDATA:http_request_info};%{GREEDYDATA}<soapenv:Envelope%{GREEDYDATA:soap_message_1}Envelope>" ]
                }
                
                mutate {
                    add_field => {"soap_message" => "<soapenv:Envelope%{soap_message_1}Envelope>"}
                }
                
            } else {
                grok {
                     patterns_dir => ["patterns"]
                     match => [ "xmessage", "<---\[HTTP request\]---;%{GREEDYDATA:http_request_info};%{GREEDYDATA}<?xml version%{GREEDYDATA:soap_message_1}Envelope>" ]
                }
                
                mutate {
                    add_field => {"soap_message" => "<?xml version%{soap_message_1}Envelope>"}
                }
            }

            
            mutate {
                gsub => [ "soap_message", ";", "" ]
                gsub => [ "soap_message", "      ", "" ]
                gsub => [ "soap_message", "  ", "" ]                
            }
            
            if [soap_message] =~ "ns2" {
                grok {
                     patterns_dir => ["patterns"]
                     match => [ "soap_message", "Body><%{GLOBS_S1:proccess}" ]
                } 
            } else {
                grok {
                     patterns_dir => ["patterns"]
                     match => [ "soap_message", "<soapenv:Body><%{GLOBS_S1:proccess}" ]
                } 
            }
            
            
            kv {
				source => "http_request_info"
				field_split_pattern =>";"
				value_split => ":"
			}
            
            xml {
                source => "soap_message"
                target => "soap"
                force_array => false
            }
        } else {
            grok {
                 patterns_dir => ["patterns"]
                 match => [ "xmessage", "<---\[HTTP request - %{GREEDYDATA:soa_endpoint}\]---;%{GREEDYDATA:http_request_info};<%{GREEDYDATA:soap_message_1}Envelope>" ]
            }
            
            mutate {
				add_field => {"soap_message" => "<%{soap_message_1}Envelope>"}

            }
            
            if [soap_message] =~ "ns1" {
                grok {
                        patterns_dir => ["patterns"]
                        match => ["soap_message", "type=\"%{GLOBS_S1:proccess}"]
                }
            } else {
                grok {
                        patterns_dir => ["patterns"]
                        match => ["soap_message", "<S:Body><%{GLOBS_S1:proccess}"]
                }
            }
            kv {
				source => "http_request_info"
				field_split_pattern =>";"
				value_split => ":"
			}
            
            xml {
                source => "soap_message"
                target => "soap"
                force_array => false
            }
        }
        
        mutate {
						remove_field => ["http_request_info","message","soap_message_1","for_xml", "end_xml", "xmessage"]
		}
        
    } else if [xmessage] =~ "HTTP response" {
        mutate {
				add_field => {"trx_type" => "http_response"}
                gsub => [ "xmessage", "\n", ";" ] 

        }
        
        if [xmessage] =~ "HTTP response - http"{
            grok {
                 patterns_dir => ["patterns"]
                 match => [ "xmessage", "<---\[HTTP response - %{GREEDYDATA:soa_endpoint} - %{GLOBS_S1:http_response_code}\]---;%{GREEDYDATA:http_request_info};<soapenv%{GREEDYDATA:soap_message_1}Envelope>" ]
            }
            
            kv {
				source => "http_request_info"
				field_split_pattern =>";"
				value_split => ":"
			}
            
            mutate {
				add_field => {"soap_message" => "<soapenv%{soap_message_1}Envelope>"}

            }
            
            grok {
                 patterns_dir => ["patterns"]
                 match => [ "soap_message", "<soapenv:Body><%{GLOBS_S1:proccess}" ]
            }
            
            xml {
                source => "soap_message"
                target => "soap"
                force_array => false
            }
        } else {
            grok {
                 patterns_dir => ["patterns"]
                 match => [ "xmessage", "<---\[HTTP response %{GLOBS_S1:http_response_code}\]---;%{GREEDYDATA:soap_message_1}Envelope>" ]
            }
            
            mutate {
				add_field => {"soap_message" => "%{soap_message_1}Envelope>"}

            }
            
            grok {
                 patterns_dir => ["patterns"]
                 match => [ "soap_message", "<S:Body><%{GLOBS_S1:proccess}" ]
            }
            
            xml {
                source => "soap_message"
                target => "soap"
                force_array => false
            }
            
        }
        
        mutate {
						remove_field => ["http_request_info","message","soap_message_1","for_xml", "end_xml", "xmessage"]
		}
    } else if [xmessage] =~ "^\<\[" {
        mutate {
				add_field => {"trx_type" => "trx1"}

        }
        
        
        if [tag1] == "Notice" {
            mutate {
                gsub => [ "xmessage", "\n\t", "" ]
                gsub => [ "xmessage", "\n", "" ]
            }        
            grok {
                     patterns_dir => ["patterns"]
                     match => [ "xmessage", "<\[%{GREEDYDATA}\] \[%{GREEDYDATA:log_status}\] %{GREEDYDATA:proccess} - %{GREEDYDATA:log_message}>" ]
            }
            mutate {
						remove_field => ["message","xmessage"]
            }
        } else {
            mutate {
                rename => ["xmessage", "log_message" ]
            }
            mutate {
						remove_field => ["message"]
            }
        }
        
        
    } else if [xmessage] =~ "^\<[A-Z]" {
        mutate {
				add_field => {"trx_type" => "trx2"}
                gsub => [ "xmessage", "\n", "" ]

        }
        if [xmessage] =~ "^\<[A-Z][a-z][a-z] [0-9][0-9], "{
                mutate {
                    add_field => {"test" => "masuknih"}
                }
                grok {
                     patterns_dir => ["patterns"]
                     match => [ "xmessage", "AM %{GLOBS_S1:main_class} %{GLOBS_S1:proccess}: %{GREEDYDATA:log_message}>" ]
                }
                if [proccess] =~ "INFO" {
                    mutate {
                        gsub => [ "proccess", "INFO", "" ]
                        add_field => {"log_status" => "INFO"}
                    }
                } else if [proccess] =~ "SEVERE" {
                    mutate {
                        gsub => [ "proccess", "SEVERE", "" ]
                        add_field => {"log_status" => "SEVERE"}
                    }
                }
        } else {
            if [xmessage] =~ "\s" {
                if [xmessage] =~ ":" {
                    grok {
                         patterns_dir => ["patterns"]
                         match => [ "xmessage", "<%{GLOBS_T1:proccess}:%{GREEDYDATA:log_message}>" ]
                        }
                } else {
                    grok {
                         patterns_dir => ["patterns"]
                         match => [ "xmessage", "<%{GLOBS_T1:proccess} %{GREEDYDATA:log_message}>" ]
                    }
                }
            } else {
                grok {
                     patterns_dir => ["patterns"]
                     match => [ "xmessage", "<%{GLOBS_T1:proccess}>" ]
                }
            }
            
        }
        mutate {
						remove_field => ["message","xmessage"]
        }
        
    }
}

output {
		stdout { 
				codec => rubydebug 
		}
		
        elasticsearch {
                            index => "dev-globs-%{+YYYY.MM.dd}"
                            hosts => ["https://192.168.45.15:443"]
                            #cacert => "/etc/logstash/coordinator.cer"
                            cacert => "D:\LOGSTASH\coordinator.cer"
                            ssl => true
                            ssl_certificate_verification => false
                            user => logstash_internal
                            password => ZaM7Xc2Y74Gd
        }
}
