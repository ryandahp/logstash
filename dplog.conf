input {
	file {
			path => ["C:/Users/Administrator/Documents/dplog/*"]
	}
}

filter {
	if [message] =~ "^#" {
		drop {}
	} else {
	if [path] =~ "mpg" {
       if [message] =~ "\*\*\*SENT MESSAGE" {
				grok {
						 patterns_dir => ["patterns"]
						 match => [ "message", "%{SOA_MPG}" ]
						 add_field => {"log_type" => "mpg"}
				}
				
				mutate {
					gsub => [ "xml_data_incoming", "<methodCall>", "" ]
					gsub => [ "xml_data_incoming", "<methodName>", "methodName=" ]
					gsub => [ "xml_data_incoming", "BNI.smsPull", "" ]
					gsub => [ "xml_data_incoming", "</methodName>", "|" ]
					gsub => [ "xml_data_incoming", "</methodCall>", "" ]
					gsub => [ "xml_data_incoming", "<params><member><name>", "" ]
					gsub => [ "xml_data_incoming", "</value></member></params>", "" ]
					gsub => [ "xml_data_incoming", "</name><value>", "=" ]
					gsub => [ "xml_data_incoming", "</value></member><member><name>", "|" ]
					gsub => [ "xml_data_incoming", "\r", "" ]
				}
				
				kv {
								source => "xml_data_incoming"
								field_split_pattern =>"\|"
								value_split => "="
				}
				
				date {
						match => ["TransactionDate", "yyyyMMdd'T'HH:mm:ss:SSS"]
						target => "@timestamp"
				}
				
				date {
						match => ["TransactionDate", "yyyyMMdd'T'HH:mm:ss:SSS"]
						target => "transactionDate"
				}
				date {
						match => ["ReffTransactionDate", "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]
						target => "reffTransactionDate"
				}
				
				mutate {
					remove_field => ["xml_data_incoming","message"]
				}

				ruby {
							init => "require 'time'"
							code => "
								waktu_INCOMING = (event.get('reffTransactionDate')).to_f;
								waktu_FWDSOA = (event.get('transactionDate')).to_f;
								time_taken = (waktu_INCOMING - waktu_FWDSOA);
								event.set('rt_trx_ms', ((time_taken) * 1000).round(0));
							"
				}
		}
		
		if [SMSContent] =~ "SMS BANKING" {
			if [SMSContent] =~ "Saldo rekening" {
					mutate {
						gsub => ["SMSContent","Rp.(\w)\w* (\w)\w*","\1\2"]
					}
			}
		}
	} else if [message] =~ "fw" {	
		 if [message] =~ "\*\*\*INCOMING"{
				grok {
						 patterns_dir => ["patterns"]
						 match => [ "message", "%{SOA_FW}" ]
				}
				
				mutate {
					gsub => [ "xml_data_incoming", "#012", "" ]
					gsub => [ "xml_data_incoming", "#011", "" ]
					gsub => [ "xml_data_incoming", "<methodCall>", "" ]
					gsub => [ "xml_data_incoming", "<methodName>", "" ]
					gsub => [ "xml_data_incoming", "BNI.smsPull", "" ]
					gsub => [ "xml_data_incoming", "</methodName>", "" ]
					gsub => [ "xml_data_incoming", "</methodCall>", "" ]
					gsub => [ "xml_data_incoming", "<params><member><name>", "" ]
					gsub => [ "xml_data_incoming", "</value></member></params>", "" ]
					gsub => [ "xml_data_incoming", "</name><value>", "=" ]
					gsub => [ "xml_data_incoming", "</value></member><member><name>", "|" ]
					gsub => [ "xml_data_incoming", "\r", "" ]
				}
				
				kv {
								source => "xml_data_incoming"
								field_split_pattern =>"\|"
								value_split => "="
				}
				
				date {
						match => ["TransactionDate", "yyyyMMdd'T'HH:mm:ss:SSS"]
						target => "@timestamp"
						timezone => "Asia/Jakarta"
				}
				
				mutate {
					remove_field => ["message", "[zmap][TransactionDate]", "[zmap][reffTransactionDate]","xml_data_incoming"]
				}
			
		} else if [message] =~ "\*\*\*FORWARDED TO SOA"{
				grok {
						 patterns_dir => ["patterns"]
						 match => [ "message", "%{SOA_FW}" ]
						 add_field => {"log_type" => "fw"}
				}
				
				mutate {
					gsub => [ "xml_data_incoming", "#012", "" ]
					gsub => [ "xml_data_incoming", "<sm:transaction xmlns:sm=\"http://service.bni.co.id/smsapp\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><headerIn>", "" ]
					gsub => [ "xml_data_incoming", "</headerIn>", "" ]
					gsub => [ "xml_data_incoming", "</content></sm:transaction>", "" ]
					gsub => [ "xml_data_incoming", "<content xsi:type=\"sm:SmsMessage\">", "" ]
					gsub => [ "xml_data_incoming", "</smsProviderId>", "|" ]
					gsub => [ "xml_data_incoming", "</msisdn>", "|" ]
					gsub => [ "xml_data_incoming", "</transactionType>", "|" ]
					gsub => [ "xml_data_incoming", "</transactionId>", "|" ]
					gsub => [ "xml_data_incoming", "</transactionDate>", "|" ]
					gsub => [ "xml_data_incoming", "</reffTransactionId>", "|" ]
					gsub => [ "xml_data_incoming", "</reffTransactionDate>", "|" ]
					gsub => [ "xml_data_incoming", "</originalMessage>", "|" ]
					gsub => [ "xml_data_incoming", "</commandType>", "|" ]
					gsub => [ "xml_data_incoming", "</message>", "" ]
					gsub => [ "xml_data_incoming", "</content>", "" ]
					gsub => [ "xml_data_incoming", "</sm:transaction>", "" ]
					gsub => [ "xml_data_incoming", "</sm:transactio", "" ]
					gsub => [ "xml_data_incoming", "<", "" ]
					gsub => [ "xml_data_incoming", ">", "=" ]
					gsub => [ "xml_data_incoming", "\r", "" ]
				}
				
				kv {
								source => "xml_data_incoming"
								field_split_pattern =>"\|"
								value_split => "="
				}
				
				date {
						match => ["transactionDate", "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]
						target => "@timestamp"
						timezone => "Asia/Jakarta"
				}
				
				date {
						match => ["transactionDate", "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]
						target => "transactionDate"
				}
				date {
						match => ["reffTransactionDate", "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]
						target => "reffTransactionDate"
				}

				mutate {
					remove_field => ["message", "[zmap][TransactionDate]", "[zmap][reffTransactionDate]","xml_data_incoming"]
				}
				
				ruby {
							init => "require 'time'"
							code => "
								waktu_INCOMING = (event.get('reffTransactionDate')).to_f;
								waktu_FWDSOA = (event.get('transactionDate')).to_f;
								#time_taken = (waktu_FWDSOA - waktu_INCOMING);
								time_taken = (waktu_INCOMING - waktu_FWDSOA);
								event.set('rt_trx_ms', ((time_taken) * 1000).round(0));
							"
				}
				mutate {
					rename => { "msisdn" => "MSISDN" }
				}
		} else if [message] =~ "\*\*\*REJECTED"{
				grok {
						 patterns_dir => ["patterns"]
						 match => [ "message", "%{SOA_INCOMING_REJECTED}" ]
				}
				
				mutate {
					gsub => [ "xml_data_incoming", "#012", "" ]
					gsub => [ "xml_data_incoming", "#011", "" ]
					gsub => [ "xml_data_incoming", "<methodCall>", "" ]
					gsub => [ "xml_data_incoming", "<methodName>", "" ]
					gsub => [ "xml_data_incoming", "BNI.smsPull", "" ]
					gsub => [ "xml_data_incoming", "</methodName>", "" ]
					gsub => [ "xml_data_incoming", "</methodCall>", "" ]
					gsub => [ "xml_data_incoming", "<params><member><name>", "" ]
					gsub => [ "xml_data_incoming", "</value></member></params>", "" ]
					gsub => [ "xml_data_incoming", "</name><value>", "=" ]
					gsub => [ "xml_data_incoming", "</value></member><member><name>", "|" ]
					gsub => [ "xml_data_incoming", "\r", "" ]
				}
				
				kv {
								source => "xml_data_incoming"
								field_split_pattern =>"\|"
								value_split => "="
				}
				
				date {
						match => ["TransactionDate", "yyyyMMdd'T'HH:mm:ss:SSS"]
						target => "@timestamp"
						timezone => "Asia/Jakarta"
				}
				
				mutate {
					remove_field => ["message", "[zmap][TransactionDate]", "[zmap][reffTransactionDate]","xml_data_incoming"]
				}
		
		} else {
			drop {}
		}
		
		aggregate {
						   task_id => "%{trans_id}"
						   code => "
								if event.get('state_type') == '***INCOMING' then
									map['state_type'] = event.get('state_type');
									map['@timestamp'] = event.get('@timestamp');
									map['MSISDN'] = event.get('MSISDN');
									map['SMSContent'] = event.get('SMSContent');
								end;
								if event.get('state_type') == '***FORWARDED TO SOA' then
									map['rt_trx_ms'] = event.get('rt_trx_ms');
									map['state_type'] = event.get('state_type');
									map['@timestamp'] = event.get('@timestamp');
									map['smsProviderId'] = event.get('smsProviderId');
									map['reffTransactionId'] = event.get('reffTransactionId');
									map['commandType'] = event.get('commandType');
								end;
								event.cancel(); 
						   "
						   push_map_as_event_on_timeout => true
						   timeout_task_id_field => "trans_id"
						   inactivity_timeout => 5
						   timeout => 300
						   map_action => "create_or_update"
		}
		
		if [state_type] == "***FORWARDED TO SOA" {
				mutate {
					add_field => { "status" => "success" }
				}
		} else if [state_type] == "***INCOMING" {
				mutate {
					add_field => { "status" => "failed" }
				}
		}
		
	} else {
		drop{}
	}
 } 
 }
output {
   stdout { codec => rubydebug }
	#elasticsearch {
	#		 hosts => ["http://192.168.45.15:443"]
	#	     index => "test-dp-fw-mpg-%{+YYYY.MM}"
	#}
	
	elasticsearch {
			index => "test-dp-fw-mpg-%{+YYYY.MM}"
                        hosts => ["https://192.168.45.15:443"]
                        cacert => "D:\LOGSTASH\coordinator.cer"
                        ssl => true
                        ssl_certificate_verification => false
                        user => logstash_internal
                        password => ZaM7Xc2Y74Gd
	}		
}